# make_podshox_zip.py
# Ishlatish: python make_podshox_zip.py
# Natija: podshox_bot/ papkasi va podshox_bot.zip arxivi yaratiladi.
import os
import zipfile

base = "podshox_bot"

structure = {
    # Asosiy bot fayli (bot.py)
    "bot.py": r'''import os
import json
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.types import ContentType, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils import executor

from config import BOT_TOKEN, ADMIN_ID, CHANNELS, MAX_FREE_SIZE_BYTES, PREMIUM_FEE, CARD_INFO
from watermark import add_watermark
from music import search_and_download_audio
from payment import request_payment, confirm_payment, check_paid
from subscription import is_subscribed
from qa import answer_question

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot)

# Local users store (users.json)
USERS_FILE = "users.json"
if os.path.exists(USERS_FILE):
    with open(USERS_FILE, "r", encoding="utf-8") as f:
        users = json.load(f)
else:
    users = {}

def save_users():
    with open(USERS_FILE, "w", encoding="utf-8") as f:
        json.dump(users, f, ensure_ascii=False, indent=2)

# Menyular har uch til uchun (eng oddiy)
def keyboard_for_lang(lang):
    if lang == "uz":
        kb = [
            [KeyboardButton("üé¨ Video yuklash"), KeyboardButton("üéµ Musiqa topish")],
            [KeyboardButton("ü§ñ IA Podshox'ga savol berish"), KeyboardButton("üìû Admin bilan aloqa")]
        ]
    elif lang == "ru":
        kb = [
            [KeyboardButton("üé¨ –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ"), KeyboardButton("üéµ –ù–∞–π—Ç–∏ –º—É–∑—ã–∫—É")],
            [KeyboardButton("ü§ñ –°–ø—Ä–æ—Å–∏—Ç—å IA Podshox"), KeyboardButton("üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∞–¥–º–∏–Ω–æ–º")]
        ]
    else:  # en
        kb = [
            [KeyboardButton("üé¨ Download video"), KeyboardButton("üéµ Find music")],
            [KeyboardButton("ü§ñ Ask Podshox AI"), KeyboardButton("üìû Contact admin")]
        ]
    return ReplyKeyboardMarkup(kb, resize_keyboard=True)

# Til tanlash
@dp.message_handler(commands=['start'])
async def cmd_start(message: types.Message):
    uid = str(message.from_user.id)
    # agar yangi foydalanuvchi bo'lsa default til uz
    if uid not in users:
        users[uid] = {"lang":"uz", "paid": False}
        save_users()
    # avvalo obuna tekshiruvi va til tanlash tugmalari
    markup = ReplyKeyboardMarkup(
        [
            [KeyboardButton("üá∫üáø O'zbekcha"), KeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π"), KeyboardButton("üá¨üáß English")]
        ],
        resize_keyboard=True
    )
    await message.reply("Tilni tanlang / –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Choose a language", reply_markup=markup)

# Tilni tanlash handler
@dp.message_handler(lambda m: m.text in ["üá∫üáø O'zbekcha","üá∑üá∫ –†—É—Å—Å–∫–∏–π","üá¨üáß English"])
async def choose_lang(message: types.Message):
    uid = str(message.from_user.id)
    txt = message.text
    if txt.startswith("üá∫üáø"):
        lang = "uz"
    elif txt.startswith("üá∑üá∫"):
        lang = "ru"
    else:
        lang = "en"
    users[uid]["lang"] = lang
    save_users()
    # Majburiy obuna tekshirilsin
    ok, not_joined = await is_subscribed(bot, int(uid), CHANNELS)
    if not ok:
        # tilga mos xabar
        if lang=="uz":
            await message.reply("üîî Iltimos quyidagi kanallarga obuna bo'ling va /check ni bosing:\n" + "\\n".join(not_joined))
        elif lang=="ru":
            await message.reply("üîî –ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã –∏ –Ω–∞–∂–º–∏—Ç–µ /check:\n" + "\\n".join(not_joined))
        else:
            await message.reply("üîî Please subscribe to the channels below and press /check:\n" + "\\n".join(not_joined))
        return
    await message.reply("‚úÖ Tayyor! Asosiy menyu ochildi.", reply_markup=keyboard_for_lang(lang))

# /check komandasi - foydalanuvchi obunasini tekshiradi
@dp.message_handler(commands=['check'])
async def cmd_check(message: types.Message):
    uid = message.from_user.id
    ok, not_joined = await is_subscribed(bot, uid, CHANNELS)
    lang = users.get(str(uid), {}).get("lang", "uz")
    if ok:
        if lang=="uz": await message.reply("‚úÖ Siz barcha kanallarga obunasiz.", reply_markup=keyboard_for_lang(lang))
        elif lang=="ru": await message.reply("‚úÖ –í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã.", reply_markup=keyboard_for_lang(lang))
        else: await message.reply("‚úÖ You are subscribed to all channels.", reply_markup=keyboard_for_lang(lang))
    else:
        if lang=="uz": await message.reply("‚ö†Ô∏è Iltimos quyidagi kanallarga obuna bo'ling:\n" + "\\n".join(not_joined))
        elif lang=="ru": await message.reply("‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–µ –∫–∞–Ω–∞–ª—ã:\n" + "\\n".join(not_joined))
        else: await message.reply("‚ö†Ô∏è Please subscribe to the following channels:\n" + "\\n".join(not_joined))

# Musiqa qidirish komanda
@dp.message_handler(lambda m: m.text and m.text.startswith("/music_search"))
async def cmd_music_search(message: types.Message):
    parts = message.text.split(maxsplit=1)
    if len(parts)<2:
        await message.reply("Foydalanish: /music_search <qo'shiq nomi>")
        return
    query = parts[1]
    await message.reply("üîé Qidirilmoqda...")
    file_info, info = search_and_download_audio(query)
    if file_info:
        try:
            await message.reply_audio(audio=open(file_info,"rb"), title=(info["entries"][0]["title"] if info else None))
            os.remove(file_info)
        except Exception as e:
            await message.reply(f"‚ùå Xato: {e}")
    else:
        await message.reply("‚ùå Musiqa topilmadi yoki yuklab bo'lmadi.")

# Video yuklash handler (foydalanuvchi menyudan video yuklashni bosganda video yuboradi)
@dp.message_handler(content_types=[ContentType.VIDEO])
async def handle_video(message: types.Message):
    uid = message.from_user.id
    lang = users.get(str(uid), {}).get("lang","uz")
    # obuna tekshiruvi
    ok, not_joined = await is_subscribed(bot, uid, CHANNELS)
    if not ok:
        await message.reply("üîî Iltimos kanallarga obuna bo'ling va /check bosing.")
        return
    size = message.video.file_size or 0
    # agar kattaroq bo'lsa va to'lov qilinmagan bo'lsa
    if size > MAX_FREE_SIZE_BYTES and not check_paid(uid):
        request_payment(uid, PREMIUM_FEE)
        cinfo = CARD_INFO
        await message.reply(f"‚ö†Ô∏è Faylingiz juda katta ({size} bayt). Premium uchun {PREMIUM_FEE} so‚Äòm to‚Äòlang.\nKarta: {cinfo}\nTo‚Äòlovdan so‚Äòng chekni botga yuboring, admin tasdiqlaydi.")
        await bot.send_message(ADMIN_ID, f"üí≥ Foydalanuvchi {uid} katta fayl yuklamoqchi ‚Äî to'lov kerak ({PREMIUM_FEE}).")
        return
    await message.reply("‚è≥ Video yuklanmoqda...")
    try:
        f = await message.video.download(destination_dir=".")
        file_path = f.name if hasattr(f,"name") else f
    except Exception as e:
        await message.reply(f"‚ùå Yuklashda xato: {e}")
        return
    await message.reply("üé¨ Watermark qo'yilmoqda...")
    wm = add_watermark(file_path)
    if wm and os.path.exists(wm):
        await message.reply_video(video=open(wm,"rb"))
        try:
            os.remove(wm)
            os.remove(file_path)
        except:
            pass
        await bot.send_message(ADMIN_ID, f"üé¨ {uid} video qaytarildi.")
    else:
        await message.reply("‚ùå Watermark qo'yishda xato yuz berdi.")

# QA tugmasi bosilganda - userdan savol qabul qilamiz (oddiy keyword-based)
user_modes = {}
@dp.message_handler(lambda m: m.text in ["ü§ñ IA Podshox'ga savol berish","ü§ñ –°–ø—Ä–æ—Å–∏—Ç—å IA Podshox","ü§ñ Ask Podshox AI"])
async def start_qa(message: types.Message):
    user_modes[message.from_user.id] = "qa"
    await message.reply("‚ùì Savolingizni yozing. (Yoki /cancel)")

@dp.message_handler(commands=['cancel'])
async def cancel_mode(message: types.Message):
    user_modes.pop(message.from_user.id, None)
    await message.reply("‚úÖ Bekor qilindi.", reply_markup=keyboard_for_lang(users.get(str(message.from_user.id),{}).get("lang","uz")))

@dp.message_handler(content_types=[ContentType.TEXT])
async def handle_text(message: types.Message):
    uid = message.from_user.id
    text = message.text.strip()
    # admin confirm pay
    if text.startswith("/confirmpay"):
        if str(uid) != str(ADMIN_ID):
            await message.reply("‚õî Faqat admin.")
            return
        parts = text.split()
        if len(parts)<2:
            await message.reply("Foydalanuvchi ID kiriting: /confirmpay <user_id>")
            return
        target = parts[1]
        ok = confirm_payment(target)
        if ok:
            await message.reply(f"‚úÖ {target} uchun to'lov tasdiqlandi.")
            await bot.send_message(int(target), "‚úÖ To'lov tasdiqlandi. Endi faylingiz qayta ishlanadi.")
        else:
            await message.reply("‚ùå To'lov topilmadi.")
        return
    # adminga xabar yuborish (admin bilan aloqa)
    if text in ["üìû Admin bilan aloqa","üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∞–¥–º–∏–Ω–æ–º","üìû Contact admin"]:
        await bot.send_message(ADMIN_ID, f"üì© Foydalanuvchi {uid} admin bilan aloqa qilmoqchi.")
        await message.reply("‚úÖ Adminga xabaringiz yuborildi.")
        return
    # QA rejimi
    if user_modes.get(uid) == "qa":
        ans = answer_question(text)
        await message.reply(ans)
        return
    # boshqa matnlar
    await message.reply("Menyudan birini tanlang.", reply_markup=keyboard_for_lang(users.get(str(uid),{}).get("lang","uz")))
    
def main():
    executor.start_polling(dp, skip_updates=True)

if __name__ == "__main__":
    main()
''',

    # Watermark util
    "watermark.py": r'''import os
from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip

def add_watermark(input_path, tag="@podshox_bot"):
    try:
        base = os.path.basename(input_path)
        outname = f"watermarked_{base}"
        output_path = os.path.join(os.path.dirname(input_path), outname)
        clip = VideoFileClip(input_path)
        txt = (TextClip(tag, fontsize=24, color='white', font='Arial-Bold')
               .set_position(("left","bottom"))
               .set_duration(clip.duration))
        final = CompositeVideoClip([clip, txt])
        final.write_videofile(output_path, codec='libx264', audio_codec='aac')
        clip.close()
        final.close()
        return output_path
    except Exception as e:
        print("Watermark error:", e)
        return None
''',

    # Music module (yt-dlp)
    "music.py": r'''import os
import yt_dlp
from time import time

def search_and_download_audio(query, output_dir="."):
    safe_name = f"audio_{int(time())}.mp3"
    outtmpl = os.path.join(output_dir, safe_name)
    opts = {
        "format":"bestaudio/best",
        "outtmpl": outtmpl,
        "postprocessors":[{"key":"FFmpegExtractAudio","preferredcodec":"mp3"}],
        "noplaylist": True,
        "quiet": True
    }
    try:
        with yt_dlp.YoutubeDL(opts) as ydl:
            info = ydl.extract_info(f"ytsearch:{query}", download=True)
        if os.path.exists(outtmpl):
            return outtmpl, info
    except Exception as e:
        print("music error:", e)
    return None, None
''',

    # Payment (manual card)
    "payment.py": r'''import json
import os
from time import time

PAY_FILE = "payments.json"

def load_payments():
    if os.path.exists(PAY_FILE):
        with open(PAY_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_payments(d):
    with open(PAY_FILE, "w", encoding="utf-8") as f:
        json.dump(d, f, ensure_ascii=False, indent=2)

def request_payment(user_id, amount):
    d = load_payments()
    d[str(user_id)] = {"amount": amount, "paid": False, "ts": int(time())}
    save_payments(d)
    return True

def confirm_payment(user_id):
    d = load_payments()
    uid = str(user_id)
    if uid in d:
        d[uid]["paid"] = True
        save_payments(d)
        return True
    return False

def check_paid(user_id):
    d = load_payments()
    return d.get(str(user_id), {}).get("paid", False)
''',

    # Subscription helper
    "subscription.py": r'''# subscription.py
async def is_subscribed(bot, user_id, channels):
    not_joined = []
    for ch in channels:
        try:
            member = await bot.get_chat_member(ch, user_id)
            if member.status not in ("member","creator","administrator"):
                not_joined.append(ch)
        except Exception:
            not_joined.append(ch)
    if not_joined:
        return False, not_joined
    return True, []
''',

    # Simple QA module
    "qa.py": r'''import re

FAQ = [
    {"q_keywords":["300mb","limit","limit 300mb","300 mb"], "answer":"Bepul limit 300MB. Katta fayllar uchun to‚Äòlov kerak."},
    {"q_keywords":["watermark","pechat","@podshox_bot"], "answer":"Video chap past burchagida @podshox_bot yozuvi qo‚Äòyiladi."},
    {"q_keywords":["music","musiqa","mp3"], "answer":"/music_search <qo'shiq nomi> orqali toping."},
]

FALLBACK = "Iltimos savolingizni qisqaroq yozing yoki /start ni bosing."

def normalize(t):
    t = t.lower()
    t = re.sub(r"[^\w\s@]", " ", t)
    return t

def answer_question(text):
    t = normalize(text)
    for faq in FAQ:
        for kw in faq["q_keywords"]:
            if kw in t:
                return faq["answer"]
    return FALLBACK
''',

    # Admin panel (simple CLI via bot commands for admin)
    "admin_panel.py": r'''import json
import os
from config import ADMIN_ID

CHANNELS_FILE = "channels.json"
USERS_FILE = "users.json"

def load_channels():
    if os.path.exists(CHANNELS_FILE):
        with open(CHANNELS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return []

def save_channels(ch):
    with open(CHANNELS_FILE, "w", encoding="utf-8") as f:
        json.dump(ch, f, ensure_ascii=False, indent=2)

# admin command examples (these are used by Bot.py to manage channels)
def add_channel(username):
    ch = load_channels()
    if username not in ch:
        ch.append(username)
        save_channels(ch)
        return True
    return False

def remove_channel(username):
    ch = load_channels()
    if username in ch:
        ch.remove(username)
        save_channels(ch)
        return True
    return False

def list_channels():
    return load_channels()
''',

    # config.py with placeholders (do NOT put real token here)
    "config.py": r'''import os
from dotenv import load_dotenv
load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")  # Put your bot token in .env
ADMIN_ID = int(os.getenv("ADMIN_ID") or 0)
# channels managed via channels.json (admin can add/remove)
CHANNELS = []
MAX_FREE_SIZE_BYTES = int(os.getenv("MAX_FREE_SIZE_BYTES") or 300*1024*1024)
PREMIUM_FEE = int(os.getenv("PREMIUM_FEE") or 20000)
CARD_INFO = os.getenv("CARD_INFO") or "9860 1601 3090 8306 Yusufjanov B"
''',

    # channels.json starter (empty list)
    "channels.json": "[]",
    # users.json starter
    "users.json": "{}",
    # requirements
    "requirements.txt": "aiogram\nmoviepy\nyt-dlp\npython-dotenv\n",
    # README
    "README.md": r'''# Podshox Bot (Universal Premium)

## Qisqacha
Podshox Bot ‚Äî video muzika va savol-javob xizmati bilan Telegram bot. 
U avtomatik video watermark qo'yadi, musiqa qidiradi, 300MB dan katta fayllar uchun qo'lda to'lov talab qiladi va majburiy kanal obunasini tekshiradi.

## Ishga tushirish
1. Python o'rnating (3.8+)
2. Kutubxonalarni o'rnating:
   pip install -r requirements.txt
3. .env fayliga quyidagilarni yozing:
   BOT_TOKEN=your_token_here
   ADMIN_ID=1025705317
   # ixtiyoriy:
   # CHANNELS=@chan1,@chan2
   # MAX_FREE_SIZE_BYTES=314572800
   # PREMIUM_FEE=20000
4. Botni ishga tushiring:
   python bot.py

## Admin komandalar
- /confirmpay <user_id>  ‚Äî to'lovni admin qo'lda tasdiqlashi
- Admin kanallarni add/remove funksiyalari bot orqali amalga oshiriladi (kod ichida admin_panel.py dan foydalaniladi).

## Eslatma
MoviePy va yt-dlp video/audio qayta ishlashda CPU/ram talab qiladi. Serverda yetarli resurs bo'lishi kerak.
''',
    # .env template
    ".env": "BOT_TOKEN=\nADMIN_ID=\n# CHANNELS can be left empty; admin can add channels via admin panel commands later.\n# Example: CHANNELS=@podshoxnews,@podshoxmedia\n# MAX_FREE_SIZE_BYTES=314572800\n# PREMIUM_FEE=20000\n# CARD_INFO=9860160130908306 Yusufjanov B\n",
}

# Yaratish
os.makedirs(base, exist_ok=True)
for fname, content in structure.items():
    path = os.path.join(base, fname)
    # if content meant to be JSON files, write as is
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)

# Zip qilish
zip_name = f"{base}.zip"
with zipfile.ZipFile(zip_name, "w", zipfile.ZIP_DEFLATED) as zf:
    for root, dirs, files in os.walk(base):
        for file in files:
            full = os.path.join(root, file)
            arc = os.path.relpath(full, base)
            zf.write(full, arcname=arc)

print(f"‚úÖ '{zip_name}' yaratildi va '{base}/' papkasi to‚Äòldirildi. .env faylni to‚Äòldiring va kutubxonalarni o‚Äòrnating (pip install -r {base}/requirements.txt).")